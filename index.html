<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ§Š</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- cubejs ships browser builds that expose a global `Cube` Kociemba solver -->
    <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/cube.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cubejs@1.3.2/lib/solve.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ==================== RUBIK'S CUBE SOLVING SYSTEM ====================

        // Wrapper around cubejs' two-phase (Kociemba) solver
        class KociembaSolver {
            constructor() {
                this.initialized = false;
                this.initPromise = null;
            }

            async ensureReady() {
                if (this.initialized) return;
                if (!window.Cube) {
                    throw new Error('cubejs solver failed to load');
                }
                if (!this.initPromise) {
                    // Cube.initSolver() is synchronous but expensive; wrap in a promise for consistent await
                    this.initPromise = Promise.resolve().then(() => {
                        window.Cube.initSolver();
                        this.initialized = true;
                    });
                }
                return this.initPromise;
            }

            async solve(scrambleMoves) {
                await this.ensureReady();
                const scrambleString = scrambleMoves.join(' ');
                const cube = new window.Cube();
                cube.move(scrambleString);
                const solutionString = cube.solve();
                return solutionString
                    .trim()
                    .split(/\s+/)
                    .filter(Boolean);
            }
        }

        // Scramble Generator
        function generateScramble(length = 25) {
            const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
            const modifiers = ['', "'", '2'];
            const scramble = [];
            let lastFace = null;

            const oppositeFace = {
                'R': 'L', 'L': 'R',
                'U': 'D', 'D': 'U',
                'F': 'B', 'B': 'F'
            };

            while (scramble.length < length) {
                const face = faces[Math.floor(Math.random() * faces.length)];

                // Avoid consecutive moves on same or opposite faces
                if (face === lastFace || face === oppositeFace[lastFace]) {
                    continue;
                }

                const mod = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(face + mod);
                lastFace = face;
            }

            return scramble;
        }

        // Move Executor with Animation
        class MoveExecutor {
            constructor(pieceLocator, cubeRoot) {
                this.pieceLocator = pieceLocator;
                this.cubeRoot = cubeRoot;
                this.sceneRoot = cubeRoot.parent;

                // Rotation axes for each face (in cube space)
                this.AXES = {
                    'R': new THREE.Vector3(1, 0, 0),   // Right
                    'L': new THREE.Vector3(-1, 0, 0),  // Left
                    'U': new THREE.Vector3(0, 1, 0),   // Up
                    'D': new THREE.Vector3(0, -1, 0),  // Down
                    'F': new THREE.Vector3(0, 0, 1),   // Front
                    'B': new THREE.Vector3(0, 0, -1)   // Back
                };
            }

            parseMove(move) {
                const face = move[0];
                let angle = -Math.PI / 2; // Clockwise when looking at the face

                if (move.includes("'")) {
                    angle = Math.PI / 2; // Counter-clockwise
                } else if (move.includes('2')) {
                    angle = Math.PI; // 180 degrees
                }

                return { face, angle };
            }

            async executeMove(move, duration) {
                const { face, angle } = this.parseMove(move);

                // Get pieces to rotate
                const pieces = this.pieceLocator.getPiecesForFace(face);
                if (!pieces || pieces.length === 0) {
                    console.warn(`No pieces found for face ${face}`);
                    return false;
                }

                // Prepare pivot group at cube center so positions follow rotation
                const pivot = new THREE.Group();
                const cubeWorldPos = new THREE.Vector3();
                this.cubeRoot.getWorldPosition(cubeWorldPos);
                pivot.position.copy(cubeWorldPos);
                this.sceneRoot.add(pivot);

                // Reparent pieces to pivot temporarily
                const originalParents = new Map();
                pieces.forEach(piece => {
                    originalParents.set(piece, piece.parent);
                    pivot.attach(piece);
                });

                // Animate rotation
                await this.animatePivotRotation(pivot, this.AXES[face], angle, duration);

                // Restore parents
                pieces.forEach(piece => {
                    const parent = originalParents.get(piece);
                    parent.attach(piece);
                });
                this.sceneRoot.remove(pivot);

                return true;
            }

            animatePivotRotation(pivot, axis, angle, duration) {
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    const startQuat = pivot.quaternion.clone();
                    const targetQuat = startQuat.clone().multiply(
                        new THREE.Quaternion().setFromAxisAngle(axis, angle)
                    );

                    if (duration <= 0) {
                        pivot.quaternion.copy(targetQuat).normalize();
                        resolve();
                        return;
                    }

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const t = Math.min(elapsed / duration, 1);
                        const eased = this.easeInOutCubic(t);

                        pivot.quaternion.copy(startQuat).slerp(targetQuat, eased);

                        if (t < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            pivot.quaternion.copy(targetQuat).normalize();
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        }

        // Piece Identification and Face Mapping
        function identifyPiecesAndBuildFaceMap(gltfScene) {
            const allPieces = [];

            // Update world matrices first
            gltfScene.updateMatrixWorld(true);

            // Debug: log all node names to see what's actually in the scene
            const allNames = [];
            gltfScene.traverse((node) => {
                if (node.name) {
                    allNames.push(node.name);
                }
            });
            console.log('All node names in scene (first 50):', allNames.slice(0, 50));

            // Find all cube pieces (only parent nodes, not meshes or Object nodes)
            gltfScene.traverse((node) => {
                if (node.name &&
                    !node.name.includes('_Rubik_0') &&
                    !node.name.startsWith('Object_') &&
                    (node.name.startsWith('R2.Center_') ||
                     node.name.startsWith('R2.Corner_') ||
                     node.name.startsWith('R2.Edge_') ||
                     node.name.startsWith('R2Center_') ||
                     node.name.startsWith('R2Corner_') ||
                     node.name.startsWith('R2Edge_'))
                ) {
                    allPieces.push(node);
                }
            });

            console.log(`Found ${allPieces.length} cube pieces`);

            // Helper to get actual world position (center of bounding box)
            const getPieceWorldPosition = (piece) => {
                piece.updateWorldMatrix(true, true);
                const box = new THREE.Box3().setFromObject(piece);
                const center = new THREE.Vector3();
                box.getCenter(center);
                return center;
            };

            // Get all positions to determine threshold
            const positions = allPieces.map(getPieceWorldPosition);

            // Find the range of positions to determine threshold
            let maxX = 0, maxY = 0, maxZ = 0;
            positions.forEach(pos => {
                maxX = Math.max(maxX, Math.abs(pos.x));
                maxY = Math.max(maxY, Math.abs(pos.y));
                maxZ = Math.max(maxZ, Math.abs(pos.z));
            });

            // Calculate threshold as midpoint between center and outer layer
            // Typically pieces are at -1, 0, 1 so threshold should be ~0.5
            const avgMax = (maxX + maxY + maxZ) / 3;
            const threshold = avgMax * 0.4;
            console.log(`Position range: X=${maxX.toFixed(2)}, Y=${maxY.toFixed(2)}, Z=${maxZ.toFixed(2)}`);
            console.log(`Using threshold: ${threshold.toFixed(2)}`);
            console.log(`Piece names found:`, allPieces.map(p => p.name));

            const faceSelectors = {
                'R': (pos) => pos.x > threshold,
                'L': (pos) => pos.x < -threshold,
                'U': (pos) => pos.y > threshold,
                'D': (pos) => pos.y < -threshold,
                'F': (pos) => pos.z > threshold,
                'B': (pos) => pos.z < -threshold
            };

            const getPiecesForFace = (face) => {
                const selector = faceSelectors[face];
                if (!selector) return [];
                return allPieces.filter(piece => selector(getPieceWorldPosition(piece)));
            };

            const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
            faces.forEach(face => {
                console.log(`Face ${face}: ${getPiecesForFace(face).length} pieces`);
            });

            return {
                getPiecesForFace
            };
        }

        function applySolvedPoseFromAnimation(model, animations) {
            if (!animations || animations.length === 0) {
                return;
            }

            animations.forEach(clip => {
                clip.tracks.forEach(track => {
                    const nameParts = track.name.split('.');
                    if (nameParts.length < 2) return;

                    const targetName = nameParts[0];
                    const property = nameParts[1];
                    const target = model.getObjectByName(targetName);
                    if (!target) return;

                    const valueSize = track.getValueSize();
                    const values = track.values;
                    const finalValues = values.slice(values.length - valueSize);

                    switch (property) {
                        case 'quaternion':
                            target.quaternion.fromArray(finalValues);
                            break;
                        case 'position':
                            target.position.fromArray(finalValues);
                            break;
                        case 'scale':
                            target.scale.fromArray(finalValues);
                            break;
                        default:
                            break;
                    }
                });
            });

            model.updateMatrixWorld(true);
            console.log('Applied solved pose from GLTF animation');
        }

        // Main Animation Controller
        class CubeAnimationController {
            constructor(gltfModel) {
                this.pieceLocator = identifyPiecesAndBuildFaceMap(gltfModel);
                this.executor = new MoveExecutor(this.pieceLocator, gltfModel);
                this.solver = new KociembaSolver();
                this.isRunning = false;
                this.firstCycle = true;
            }

            async startContinuousLoop() {
                if (this.isRunning) return;
                this.isRunning = true;

                console.log('Starting continuous solve/scramble loop...');

                while (this.isRunning) {
                    try {
                        // 1. Generate scramble
                        const scramble = generateScramble(25);
                        console.log('Scrambling:', scramble.join(' '));

                        // 2. Execute scramble (instant for first cycle, fast animation otherwise)
                        const scrambleDuration = this.firstCycle ? 0 : 100;
                        const executedScramble = [];
                        for (const move of scramble) {
                            const success = await this.executor.executeMove(move, scrambleDuration);
                            if (success) {
                                executedScramble.push(move);
                            }
                        }

                        if (!this.firstCycle) {
                            // 3. Brief pause after scramble
                            await this.sleep(1000);
                        }

                        // 4. Solve using cube.js' Kociemba implementation
                        console.log('Solving cube with Kociemba...');
                        if (executedScramble.length !== scramble.length) {
                            console.warn(
                                `Executed ${executedScramble.length} of ${scramble.length} scramble moves; solving actual executed sequence`
                            );
                        }
                        const scrambleForSolver = executedScramble.length ? executedScramble : scramble;
                        const solution = await this.solver.solve(scrambleForSolver);
                        console.log('Solution:', solution.join(' '), `(${solution.length} moves)`);

                        // 5. Execute solution (normal: 500ms per move)
                        for (const move of solution) {
                            await this.executor.executeMove(move, 500);
                        }

                        // 6. Pause before next cycle
                        await this.sleep(2000);

                        this.firstCycle = false;

                    } catch (error) {
                        console.error('Error in animation loop:', error);
                        await this.sleep(5000); // Wait before retry
                    }
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stop() {
                this.isRunning = false;
            }
        }

        // ==================== THREE.JS SETUP ====================

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const baseCameraPosition = new THREE.Vector3(5, 5, 5);
        const isMobileViewport = window.innerWidth <= 768;
        const mobileZoomFactor = 1.2; // move camera 20% farther back on mobile
        camera.position.copy(
            baseCameraPosition.clone().multiplyScalar(isMobileViewport ? mobileZoomFactor : 1)
        );

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 20;
        controls.target.set(0, 0, 0);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.1);
        directionalLight1.position.set(4, 9, 3);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-4, 4, -6);
        scene.add(directionalLight2);

        const detailLight = new THREE.DirectionalLight(0xffffff, 1.3);
        detailLight.position.set(-2, 2.5, 8);
        scene.add(detailLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.65);
        pointLight.position.set(0, 6, 0);
        scene.add(pointLight);

        // Load GLTF model
        const loader = new GLTFLoader();
        loader.load(
            'scene.gltf',
            function (gltf) {
                const model = gltf.scene;

                // Use embedded animation to move cube into solved pose
                applySolvedPoseFromAnimation(model, gltf.animations);

                // Center the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);

                // Scale if needed
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3 / maxDim;
                model.scale.multiplyScalar(scale);

                scene.add(model);

                // Update all matrices after adding to scene and transforming
                scene.updateMatrixWorld(true);

                // Initialize cube animation controller
                const cubeController = new CubeAnimationController(model);

                // Start continuous scramble/solve loop
                cubeController.startContinuousLoop();

                console.log('Rubik\'s Cube loaded successfully!');
                console.log('Animation controller started');
            },
            undefined,
            function (error) {
                console.error('Error loading model:', error);
            }
        );

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
