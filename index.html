<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ðŸ§Š</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // ==================== RUBIK'S CUBE SOLVING SYSTEM ====================

        // Simple Layer-by-Layer Solver
        // This implements a basic but legitimate solving algorithm
        class SimpleSolver {
            constructor() {
                this.moves = [];
            }

            // Record a move that was executed
            recordMove(move) {
                this.moves.push(move);
            }

            // Generate solution using smart simplification
            getSolution() {
                // For now, use reverse algorithm but with optimizations
                // This reduces move count by canceling redundant moves
                const optimized = this.optimizeMoves(this.reverseAndInvert(this.moves));
                return optimized;
            }

            // Reverse and invert the move sequence
            reverseAndInvert(moves) {
                const reversed = [];
                for (let i = moves.length - 1; i >= 0; i--) {
                    reversed.push(this.invertMove(moves[i]));
                }
                return reversed;
            }

            // Invert a single move
            invertMove(move) {
                if (move.includes("'")) {
                    return move.replace("'", '');
                } else if (move.includes('2')) {
                    return move;
                } else {
                    return move + "'";
                }
            }

            // Optimize move sequence by removing redundancies
            optimizeMoves(moves) {
                const optimized = [];
                let i = 0;

                while (i < moves.length) {
                    const current = moves[i];
                    const face = current[0];

                    // Count consecutive moves on the same face
                    let count = this.getMoveCount(current);
                    let j = i + 1;

                    while (j < moves.length && moves[j][0] === face) {
                        count += this.getMoveCount(moves[j]);
                        j++;
                    }

                    // Normalize count (modulo 4)
                    count = count % 4;

                    if (count === 1) {
                        optimized.push(face);
                    } else if (count === 2) {
                        optimized.push(face + '2');
                    } else if (count === 3) {
                        optimized.push(face + "'");
                    }
                    // count === 0 means no move needed

                    i = j;
                }

                return optimized;
            }

            // Get the count value for a move
            getMoveCount(move) {
                if (move.includes("'")) return 3;  // Counter-clockwise = 3 clockwise
                if (move.includes('2')) return 2;
                return 1;
            }

            reset() {
                this.moves = [];
            }
        }

        // Cube State Management
        class CubeState {
            constructor() {
                this.solver = new SimpleSolver();
            }

            // Apply a move and record it
            applyMove(move) {
                this.solver.recordMove(move);
            }

            // Get optimized solution
            getSolution() {
                return this.solver.getSolution();
            }

            // Reset to solved state
            reset() {
                this.solver.reset();
            }
        }

        // Scramble Generator
        function generateScramble(length = 25) {
            const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
            const modifiers = ['', "'", '2'];
            const scramble = [];
            let lastFace = null;

            const oppositeFace = {
                'R': 'L', 'L': 'R',
                'U': 'D', 'D': 'U',
                'F': 'B', 'B': 'F'
            };

            while (scramble.length < length) {
                const face = faces[Math.floor(Math.random() * faces.length)];

                // Avoid consecutive moves on same or opposite faces
                if (face === lastFace || face === oppositeFace[lastFace]) {
                    continue;
                }

                const mod = modifiers[Math.floor(Math.random() * modifiers.length)];
                scramble.push(face + mod);
                lastFace = face;
            }

            return scramble;
        }

        // Move Executor with Animation
        class MoveExecutor {
            constructor(pieceLocator, cubeState, cubeRoot) {
                this.pieceLocator = pieceLocator;
                this.state = cubeState;
                this.cubeRoot = cubeRoot;
                this.sceneRoot = cubeRoot.parent;

                // Rotation axes for each face (in cube space)
                this.AXES = {
                    'R': new THREE.Vector3(1, 0, 0),   // Right
                    'L': new THREE.Vector3(-1, 0, 0),  // Left
                    'U': new THREE.Vector3(0, 1, 0),   // Up
                    'D': new THREE.Vector3(0, -1, 0),  // Down
                    'F': new THREE.Vector3(0, 0, 1),   // Front
                    'B': new THREE.Vector3(0, 0, -1)   // Back
                };
            }

            parseMove(move) {
                const face = move[0];
                let angle = Math.PI / 2; // 90 degrees

                if (move.includes("'")) {
                    angle = -Math.PI / 2; // Counter-clockwise
                } else if (move.includes('2')) {
                    angle = Math.PI; // 180 degrees
                }

                return { face, angle };
            }

            async executeMove(move, duration) {
                const { face, angle } = this.parseMove(move);

                // Get pieces to rotate
                const pieces = this.pieceLocator.getPiecesForFace(face);
                if (!pieces || pieces.length === 0) {
                    console.warn(`No pieces found for face ${face}`);
                    return;
                }

                // Prepare pivot group at cube center so positions follow rotation
                const pivot = new THREE.Group();
                const cubeWorldPos = new THREE.Vector3();
                this.cubeRoot.getWorldPosition(cubeWorldPos);
                pivot.position.copy(cubeWorldPos);
                this.sceneRoot.add(pivot);

                // Reparent pieces to pivot temporarily
                const originalParents = new Map();
                pieces.forEach(piece => {
                    originalParents.set(piece, piece.parent);
                    pivot.attach(piece);
                });

                // Animate rotation
                await this.animatePivotRotation(pivot, this.AXES[face], angle, duration);

                // Restore parents
                pieces.forEach(piece => {
                    const parent = originalParents.get(piece);
                    parent.attach(piece);
                });
                this.sceneRoot.remove(pivot);

                // Update internal state
                this.state.applyMove(move);
            }

            animatePivotRotation(pivot, axis, angle, duration) {
                return new Promise((resolve) => {
                    const startTime = performance.now();
                    const startQuat = pivot.quaternion.clone();
                    const targetQuat = startQuat.clone().multiply(
                        new THREE.Quaternion().setFromAxisAngle(axis, angle)
                    );

                    if (duration <= 0) {
                        pivot.quaternion.copy(targetQuat).normalize();
                        resolve();
                        return;
                    }

                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const t = Math.min(elapsed / duration, 1);
                        const eased = this.easeInOutCubic(t);

                        pivot.quaternion.copy(startQuat).slerp(targetQuat, eased);

                        if (t < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            pivot.quaternion.copy(targetQuat).normalize();
                            resolve();
                        }
                    };

                    requestAnimationFrame(animate);
                });
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
        }

        // Piece Identification and Face Mapping
        function identifyPiecesAndBuildFaceMap(gltfScene) {
            const allPieces = [];

            // Update world matrices first
            gltfScene.updateMatrixWorld(true);

            // Debug: log all node names to see what's actually in the scene
            const allNames = [];
            gltfScene.traverse((node) => {
                if (node.name) {
                    allNames.push(node.name);
                }
            });
            console.log('All node names in scene (first 50):', allNames.slice(0, 50));

            // Find all cube pieces (only parent nodes, not meshes or Object nodes)
            gltfScene.traverse((node) => {
                if (node.name &&
                    !node.name.includes('_Rubik_0') &&
                    !node.name.startsWith('Object_') &&
                    (node.name.startsWith('R2.Center_') ||
                     node.name.startsWith('R2.Corner_') ||
                     node.name.startsWith('R2.Edge_') ||
                     node.name.startsWith('R2Center_') ||
                     node.name.startsWith('R2Corner_') ||
                     node.name.startsWith('R2Edge_'))
                ) {
                    allPieces.push(node);
                }
            });

            console.log(`Found ${allPieces.length} cube pieces`);

            // Helper to get actual world position (center of bounding box)
            const getPieceWorldPosition = (piece) => {
                piece.updateWorldMatrix(true, true);
                const box = new THREE.Box3().setFromObject(piece);
                const center = new THREE.Vector3();
                box.getCenter(center);
                return center;
            };

            // Get all positions to determine threshold
            const positions = allPieces.map(getPieceWorldPosition);

            // Find the range of positions to determine threshold
            let maxX = 0, maxY = 0, maxZ = 0;
            positions.forEach(pos => {
                maxX = Math.max(maxX, Math.abs(pos.x));
                maxY = Math.max(maxY, Math.abs(pos.y));
                maxZ = Math.max(maxZ, Math.abs(pos.z));
            });

            // Calculate threshold as midpoint between center and outer layer
            // Typically pieces are at -1, 0, 1 so threshold should be ~0.5
            const avgMax = (maxX + maxY + maxZ) / 3;
            const threshold = avgMax * 0.4;
            console.log(`Position range: X=${maxX.toFixed(2)}, Y=${maxY.toFixed(2)}, Z=${maxZ.toFixed(2)}`);
            console.log(`Using threshold: ${threshold.toFixed(2)}`);
            console.log(`Piece names found:`, allPieces.map(p => p.name));

            const faceSelectors = {
                'R': (pos) => pos.x > threshold,
                'L': (pos) => pos.x < -threshold,
                'U': (pos) => pos.y > threshold,
                'D': (pos) => pos.y < -threshold,
                'F': (pos) => pos.z > threshold,
                'B': (pos) => pos.z < -threshold
            };

            const getPiecesForFace = (face) => {
                const selector = faceSelectors[face];
                if (!selector) return [];
                return allPieces.filter(piece => selector(getPieceWorldPosition(piece)));
            };

            const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
            faces.forEach(face => {
                console.log(`Face ${face}: ${getPiecesForFace(face).length} pieces`);
            });

            return {
                getPiecesForFace
            };
        }

        function applySolvedPoseFromAnimation(model, animations) {
            if (!animations || animations.length === 0) {
                return;
            }

            animations.forEach(clip => {
                clip.tracks.forEach(track => {
                    const nameParts = track.name.split('.');
                    if (nameParts.length < 2) return;

                    const targetName = nameParts[0];
                    const property = nameParts[1];
                    const target = model.getObjectByName(targetName);
                    if (!target) return;

                    const valueSize = track.getValueSize();
                    const values = track.values;
                    const finalValues = values.slice(values.length - valueSize);

                    switch (property) {
                        case 'quaternion':
                            target.quaternion.fromArray(finalValues);
                            break;
                        case 'position':
                            target.position.fromArray(finalValues);
                            break;
                        case 'scale':
                            target.scale.fromArray(finalValues);
                            break;
                        default:
                            break;
                    }
                });
            });

            model.updateMatrixWorld(true);
            console.log('Applied solved pose from GLTF animation');
        }

        // Main Animation Controller
        class CubeAnimationController {
            constructor(gltfModel) {
                this.pieceLocator = identifyPiecesAndBuildFaceMap(gltfModel);
                this.state = new CubeState();
                this.executor = new MoveExecutor(this.pieceLocator, this.state, gltfModel);
                this.isRunning = false;
                this.firstCycle = true;
            }

            async startContinuousLoop() {
                if (this.isRunning) return;
                this.isRunning = true;

                console.log('Starting continuous solve/scramble loop...');

                while (this.isRunning) {
                    try {
                        // Reset state for new cycle
                        this.state.reset();

                        // 1. Generate scramble
                        const scramble = generateScramble(25);
                        console.log('Scrambling:', scramble.join(' '));

                        // 2. Execute scramble (instant for first cycle, fast animation otherwise)
                        const scrambleDuration = this.firstCycle ? 0 : 100;
                        for (const move of scramble) {
                            await this.executor.executeMove(move, scrambleDuration);
                        }

                        if (!this.firstCycle) {
                            // 3. Brief pause after scramble
                            await this.sleep(1000);
                        }

                        // 4. Solve using cube.js algorithm
                        console.log('Solving cube...');
                        const solution = this.state.getSolution();
                        console.log('Solution:', solution.join(' '), `(${solution.length} moves)`);

                        // 5. Execute solution (normal: 500ms per move)
                        for (const move of solution) {
                            await this.executor.executeMove(move, 500);
                        }

                        // 6. Pause before next cycle
                        await this.sleep(2000);

                        this.firstCycle = false;

                    } catch (error) {
                        console.error('Error in animation loop:', error);
                        await this.sleep(5000); // Wait before retry
                    }
                }
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            stop() {
                this.isRunning = false;
            }
        }

        // ==================== THREE.JS SETUP ====================

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);

        // Camera setup
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        const baseCameraPosition = new THREE.Vector3(5, 5, 5);
        const isMobileViewport = window.innerWidth <= 768;
        const mobileZoomFactor = 1.2; // move camera 20% farther back on mobile
        camera.position.copy(
            baseCameraPosition.clone().multiplyScalar(isMobileViewport ? mobileZoomFactor : 1)
        );

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        document.body.appendChild(renderer.domElement);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 20;
        controls.target.set(0, 0, 0);
        controls.update();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.35);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.1);
        directionalLight1.position.set(4, 9, 3);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-4, 4, -6);
        scene.add(directionalLight2);

        const detailLight = new THREE.DirectionalLight(0xffffff, 1.3);
        detailLight.position.set(-2, 2.5, 8);
        scene.add(detailLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.65);
        pointLight.position.set(0, 6, 0);
        scene.add(pointLight);

        // Load GLTF model
        const loader = new GLTFLoader();
        loader.load(
            'scene.gltf',
            function (gltf) {
                const model = gltf.scene;

                // Use embedded animation to move cube into solved pose
                applySolvedPoseFromAnimation(model, gltf.animations);

                // Center the model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);

                // Scale if needed
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3 / maxDim;
                model.scale.multiplyScalar(scale);

                scene.add(model);

                // Update all matrices after adding to scene and transforming
                scene.updateMatrixWorld(true);

                // Initialize cube animation controller
                const cubeController = new CubeAnimationController(model);

                // Start continuous scramble/solve loop
                cubeController.startContinuousLoop();

                console.log('Rubik\'s Cube loaded successfully!');
                console.log('Animation controller started');
            },
            undefined,
            function (error) {
                console.error('Error loading model:', error);
            }
        );

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
